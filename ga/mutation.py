"""
Defines mutation operations via the :class:`Mutation` class.

Extending mtk: Adding mutation functions.
-----------------------------------------

If a new mutation operation is to be added to ``mtk`` it should be
added as a method in the :class:`Mutation` class defined in this
module. The only requirement is that the first argument is `macro_mol`,
excluding any `self` or `cls` arguments.

The naming requirement of `macro_mol` exists to help users identify
which arguments are handled automatically by ``mtk`` and which they
need to define in the input file. The convention is that if the
mutation function takes an argument called  `macro_mol` it does not
have to be specified in the input file.

If the mutation function does not fit neatly into a single function,
make sure that any helper functions are private, i.e. that their names
start with a leading underscore.

"""

import os
import logging
import numpy as np
from collections import Counter
from itertools import islice

from .population import Population
from .plotting import plot_counter

logger = logging.getLogger(__name__)


class MutationError(Exception):
    """
    Used for errors which occuring during mutation operations.

    """

    ...


class Mutation:
    """
    Carries out mutations operations on a population.

    Instances of :class:`.Population` delegate mutation operations
    to instances of this class. They do this by calling

    >>> mutant_pop = pop.gen_mutants()

    which returns a new population consisting of molecules generated by
    performing mutation operations on members of ``pop``. This class
    uses the :class:`.Selection` instance in ``pop.ga_tools.selection``
    to select molecules for mutation.

    Attributes
    ----------
    funcs : :class:`list` of :class:`.FunctionData`
        This lists holds all the mutation functions which are to be
        used by the GA. One will be chosen at random when a mutation
        is desired. The likelihood that each is selected is given by
        `weights`.

    num_mutations : :class:`int`
        The number of mutations that needs to be performed each
        generation.

    weights : :class:`list` of :class:`float`
        If :attr:`weights` is a :class:`list`, each :class:`float`
        corresponds to the probability of selecting the mutation
        function at the corresponding index. If :attr:`weights` is
        ``None``, each mutation function has equal likelihood of
        being picked.

    """

    def __init__(self, funcs, num_mutations, weights=None):
        """
        Initializes a :class:`Mutation` object.

        Parameters
        ----------
        funcs : :class:`list` of :class:`.FunctionData`
            This lists holds all the mutation functions which are to be
            used by the GA. One will be chosen at random when a mutation
            is desired. The likelihood that each is selected is given by
            `weights`.

        num_mutations : :class:`int`
            The number of mutations that needs to be performed each
            generation.

        weights : :class:`list` of :class:`float`, optional
            If `weights` is a :class:`list`, each :class:`float`
            corresponds to the probability of selecting the mutation
            function at the corresponding index. If `weights` is
            ``None`` each mutation function has equal likelihood of
            being picked.

        """

        self.funcs = funcs
        self.weights = weights
        self.num_mutations = num_mutations

    def __call__(self, population, counter_path=''):
        """
        Carries out mutation operations on `population`.

        This function selects members of `population` to be mutated
        and mutates them. This goes on until either all possible
        molecules have been mutated or the required number of
        mutation operations have been performed.

        The mutants generated are returned together in a
        :class:`.Population` object. Any mutants already present in
        `population` are removed.

        Parameters
        ----------
        population : :class:`.Population`
            The population who's members are to be mutated.

        counter_path : :class:`str`, optional
            The path to the ``.png`` file showing which members were
            selected for mutation. If ``''`` then no file is made.

        Returns
        -------
        :class:`.Population`
            A population with all the mutants generated held in
            :attr:`~.Population.members`. This does not include mutants
            which correspond to molecules already present in
            `population`.

        """

        mutant_pop = Population(population.ga_tools)
        counter = Counter()

        parent_pool = islice(population.select('mutation'),
                             self.num_mutations)
        for i, parent in enumerate(parent_pool, 1):
            logger.info('Mutation number {}. Finish when {}.'.format(
                                          i, self.num_mutations))
            counter.update([parent])
            func_data = np.random.choice(self.funcs, p=self.weights)
            func = getattr(self, func_data.name)

            try:
                mutant = func(parent, **func_data.params)

                # If the mutant was retrieved from the cache, log the
                # name.
                if mutant.name:
                    logger.debug(('Mutant "{}" retrieved from '
                                  'cache.').format(mutant.name))

                mutant_pop.members.append(mutant)

            except Exception as ex:
                errormsg = ('Mutation function "{}()" '
                            'failed on molecule "{}".').format(
                             func_data.name, parent.name)
                logger.error(errormsg, exc_info=True)

        mutant_pop -= population

        if counter_path:
            # Update counter with unselected members.
            for member in population:
                if member not in counter.keys():
                    counter.update({member: 0})
            plot_counter(counter, counter_path)

        return mutant_pop

    def cage_random_bb(self, macro_mol, database, fg=None):
        """
        Substitutes a building block with a random one from a database.

        Parameters
        ----------
        macro_mol : :class:`.Cage`
            The cage who's building block will be swtiched. Note that
            the cage is not destroyed. It is used a template for a new
            cage.

        database : :class:`str`
            The full path to the database from which a new
            building block is selected.

        fg : :class:`str`, optional
            The name of a functional group defined in :mod:`.fg_info`.
            All molecules in `database` must have this functional
            group. This is the functional group which used to assemble
            the macromolecules. If ``None`` it is assumed that the
            path `database` holds the name of the functional group.

        Returns
        -------
        :class:`.Cage`
            A cage generated by taking all attributes of
            `macro_mol` except its building block. The building block
            is replaced by a random building block from `database`.

        """

        _, lk = max(zip(macro_mol.bb_counter.values(),
                        macro_mol.bb_counter.keys()))

        _, og_bb = min(zip(macro_mol.bb_counter.values(),
                           macro_mol.bb_counter.keys()))

        # Define the molecular classes.
        Cage = macro_mol.__class__
        StructUnit3 = og_bb.__class__

        while True:
            try:
                bb_file = np.random.choice(os.listdir(database))
                bb_file = os.path.join(database, bb_file)
                bb = StructUnit3(bb_file, fg)
                break

            except TypeError:
                continue

        if len(og_bb.bonder_ids) != len(bb.bonder_ids):
            raise MutationError(
                ('\n\nMUTATION ERROR: Replacement building block does'
                 ' not have the same number of functional groups as '
                 'the original building block.\n\nOriginal building '
                 'block:\n\n{}\n\nReplacement building block:\n\n'
                 '{}\n\n').format(og_bb, bb))

        return Cage([bb, lk], macro_mol.topology)

    def cage_random_lk(self, macro_mol, database, fg=None):
        """
        Substitutes a linker with a random one from a database.

        Parameters
        ----------
        macro_mol : :class:`.Cage`
            The cage who's linker will be exchanged. Note that
            the cage is not destroyed. It is used a template for a new
            cage.

        database : :class:`str`
            The full path to the database from which a new linker is to
            be found.

        fg : :class:`str`, optional
            The name of a functional group defined in :mod:`.fg_info`.
            All molecules in `database` must have this functional
            group. This is the functional group which is used to
            assemble the macromolecules. If ``None`` it is assumed that
            the path `database` holds the name of the functional group.

        Returns
        -------
        :class:`.Cage`
            A cage instance generated by taking all attributes of
            `macro_mol` except its linker which is replaced by a random
            linker from `database`.

        """

        Cage = macro_mol.__class__

        _, og_lk = max(zip(macro_mol.bb_counter.values(),
                           macro_mol.bb_counter.keys()))
        lk_type = type(og_lk)

        _, bb = min(zip(macro_mol.bb_counter.values(),
                        macro_mol.bb_counter.keys()))

        while True:
            try:
                lk_file = np.random.choice(os.listdir(database))
                lk_file = os.path.join(database, lk_file)
                lk = lk_type(lk_file, fg)
                break

            except TypeError:
                continue

        if len(og_lk.bonder_ids) != len(lk.bonder_ids):
            raise MutationError(
                 ('\n\nMUTATION ERROR: Replacement linker does not'
                  ' have the same number of functional groups as the'
                  ' original linker.\n\nOriginal linker:\n\n{}\n\n'
                  'Replacement linker:\n\n{}\n\n').format(og_lk, lk))

        return Cage([bb, lk], macro_mol.topology)

    def cage_similar_bb(self, macro_mol, database, fg=None):
        """
        Substitute the building block with similar one from `database`.

        All of the molecules in `database` are checked for similarity
        to the building block of `macro_mol`. The first time this
        mutation function is run on a cage, the most similar molecule
        in `database` is used to substitute the building block. The
        next time this mutation function is run on the same cage, the
        second most similar molecule from `database` is used and so on.

        Parameters
        ----------
        macro_mol : :class:`.Cage`
            The cage which is to have its building block substituted.

        database : :class:`str`
            The full path to the database from which molecules are used
            to substitute the building block of `macro_mol`.

        fg : :class:`str`, optional
            The name of a functional group defined in :mod:`.fg_info`.
            All molecules in `database` must have this functional
            group. This is the functional group which is used to
            assemble the macromolecules. If ``None`` it is assumed that
            the path `database` holds the name of the functional group.

        Returns
        -------
        :class:`.Cage`
            A new cage with the same linker as `macro_mol` but a
            different building block.

        """

        if not hasattr(self, '_similar_bb_mols'):
            self._similar_bb_mols = {}

        # The idea here is to create a list of molecules from
        # `database` ordered by similarity to the building block of
        # `macro_mol`. Each time this function is called on `macro_mol`
        # the next molecule from this list is used to substitute the
        # building block of the cage and create a new mutant.

        _, lk = max(zip(macro_mol.bb_counter.values(),
                        macro_mol.bb_counter.keys()))

        _, og_bb = min(zip(macro_mol.bb_counter.values(),
                           macro_mol.bb_counter.keys()))

        # Define the molecular classes.
        Cage = macro_mol.__class__
        StructUnit3 = og_bb.__class__

        if macro_mol not in self._similar_bb_mols:
            self._similar_bb_mols[macro_mol] = iter(
                                    og_bb.similar_molecules(database))

        sim_mol = next(self._similar_bb_mols[macro_mol])[-1]
        new_bb = StructUnit3(sim_mol, fg)

        if len(og_bb.bonder_ids) != len(new_bb.bonder_ids):
            raise MutationError(
              ('\n\nMUTATION ERROR: Replacement building block does'
               ' not have the same number of functional groups as '
               'the original building block.\n\nOriginal building '
               'block:\n\n{}\n\nReplacement building block:\n\n'
               '{}\n\n').format(og_bb, new_bb))

        return Cage([new_bb, lk], macro_mol.topology)

    def cage_similar_lk(self, macro_mol, database, fg=None):
        """
        Substitute the linker with a similar one from `database`.

        All of the molecules in `database` are checked for similarity
        to the linker of `macro_mol`. The first time this mutation
        function is run on a cage, the most similar molecule in
        `database` is used to substitute the linker. The next time this
        mutation function is run on the same cage, the second most
        similar molecule from `database` is used and so on.

        Parameters
        ----------
        macro_mol : :class:`.Cage`
            The cage which is to have its linker substituted.

        database : :class:`str`
            The full path of the database from which molecules are used
            to substitute the linker of `macro_mol`.

        fg : :class:`str`, optional
            The name of a functional group defined in :mod:`.fg_info`.
            All molecules in `database` must have this functional
            group. This is the functional group which is used to
            assemble the macromolecules. If ``None`` it is assumed that
            the path `database` holds the name of the functional group.

        Returns
        -------
        :class:`.Cage`
            A new cage with the same building block as `macro_mol` but
            a different linker.

        """

        Cage = macro_mol.__class__

        if not hasattr(self, '_similar_lk_mols'):
            self._similar_lk_mols = {}

        # The idea here is to create a list of molecules from
        # `database` ordered by similarity to the linker of
        # `macro_mol`. Each time this function is called on `macro_mol`
        # the next molecule from this list is used to substitute the
        # linker of the cage and create a new mutant.

        _, og_lk = max(zip(macro_mol.bb_counter.values(),
                           macro_mol.bb_counter.keys()))
        lk_type = type(og_lk)

        _, bb = min(zip(macro_mol.bb_counter.values(),
                        macro_mol.bb_counter.keys()))

        if macro_mol not in self._similar_lk_mols:
            self._similar_lk_mols[macro_mol] = iter(
                                    og_lk.similar_molecules(database))

        sim_mol = next(self._similar_lk_mols[macro_mol])[-1]
        new_lk = lk_type(sim_mol, fg)

        if len(og_lk.bonder_ids) != len(new_lk.bonder_ids):
            raise MutationError(
             ('\n\nMUTATION ERROR: Replacement linker does not'
              ' have the same number of functional groups as the'
              ' original linker.\n\nOriginal linker:\n\n{}\n\n'
              'Replacement linker:\n\n{}\n\n').format(og_lk, new_lk))

        return Cage([new_lk, bb], macro_mol.topology)

    def random_topology(self, macro_mol, topologies):
        """
        Changes `macro_mol` topology to a random one from `topologies`.

        A new instance of the same type as `macro_mol` is created. I.e.
        if `macro_mol` was a :class:`.Polymer` instance then a
        :class:`.Polymer` instance will be returned.

        Parameters
        ----------
        macro_mol : :class:`.MacroMolecule`
            The macromolecule which is to be mutated.

        topologies : :class:`list` of :class:`.Topology`
            This lists holds the topology instances from which one is
            selected at random to form a new molecule.

        Returns
        -------
        :class:`.MacroMolecule`
            A molecule generated by initializing a new instance
            with all the same parameters as `macro_mol` except for the
            topology.

        """

        tops = [x for x in topologies if
                repr(x) != repr(macro_mol.topology)]
        topology = np.random.choice(tops)
        return macro_mol.__class__(macro_mol.building_blocks, topology)
