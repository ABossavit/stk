"""
Defines mutation operations via the :class:`Mutation` class.

.. _`adding mutation functions`:

Extending stk: Adding mutation functions.
-----------------------------------------

If a new mutation operation is to be added to ``stk`` it should be
added as a method in the :class:`Mutation` class defined in this
module. The only requirement is that the first argument is `macro_mol`,
excluding any `self` or `cls` arguments.

The naming requirement of `macro_mol` exists to help users identify
which arguments are handled automatically by ``stk`` and which they
need to define in the input file. The convention is that if the
mutation function takes an argument called  `macro_mol` it does not
have to be specified in the input file.

If the mutation function does not fit neatly into a single function,
make sure that any helper functions are private, i.e. that their names
start with a leading underscore.

"""

import logging
import numpy as np
from collections import Counter
from itertools import islice
import rdkit.Chem.AllChem as rdkit

from .ga_population import GAPopulation
from .plotting import plot_counter

logger = logging.getLogger(__name__)


class MutationError(Exception):
    """
    Used for errors which occuring during mutation operations.

    """

    ...


class Mutation:
    """
    Carries out mutations operations on a population.

    Instances of :class:`.GAPopulation` delegate mutation operations
    to instances of this class. They do this by calling

    >>> mutant_pop = pop.gen_mutants()

    which returns a new population consisting of molecules generated by
    performing mutation operations on members of ``pop``. This class
    uses the :class:`.Selection` instance in ``pop.ga_tools.selection``
    to select molecules for mutation.

    Attributes
    ----------
    funcs : :class:`list` of :class:`.FunctionData`
        This lists holds all the mutation functions which are to be
        used by the GA. One will be chosen at random when a mutation
        is desired. The likelihood that each is selected is given by
        `weights`.

    num_mutations : :class:`int`
        The number of mutations that needs to be performed each
        generation.

    weights : :class:`list` of :class:`float`
        If :attr:`weights` is a :class:`list`, each :class:`float`
        corresponds to the probability of selecting the mutation
        function at the corresponding index. If :attr:`weights` is
        ``None``, each mutation function has equal likelihood of
        being picked.

    """

    def __init__(self, funcs, num_mutations, weights=None):
        """
        Initializes a :class:`Mutation` object.

        Parameters
        ----------
        funcs : :class:`list` of :class:`.FunctionData`
            This lists holds all the mutation functions which are to be
            used by the GA. One will be chosen at random when a mutation
            is desired. The likelihood that each is selected is given by
            `weights`.

        num_mutations : :class:`int`
            The number of mutations that needs to be performed each
            generation.

        weights : :class:`list` of :class:`float`, optional
            If `weights` is a :class:`list`, each :class:`float`
            corresponds to the probability of selecting the mutation
            function at the corresponding index. If `weights` is
            ``None`` each mutation function has equal likelihood of
            being picked.

        """

        self.funcs = funcs
        self.weights = weights
        self.num_mutations = num_mutations

    def __call__(self, population, counter_path=''):
        """
        Carries out mutation operations on `population`.

        This function selects members of `population` to be mutated
        and mutates them. This goes on until either all possible
        molecules have been mutated or the required number of
        mutation operations have been performed.

        The mutants generated are returned together in a
        :class:`.GAPopulation` object. Any mutants already present in
        `population` are removed.

        Parameters
        ----------
        population : :class:`.GAPopulation`
            The population who's members are to be mutated.

        counter_path : :class:`str`, optional
            The path to the ``.png`` file showing which members were
            selected for mutation. If ``''`` then no file is made.

        Returns
        -------
        :class:`.GAPopulation`
            A population with all the mutants generated held in
            :attr:`~.Population.members`. This does not include mutants
            which correspond to molecules already present in
            `population`.

        """

        mutant_pop = GAPopulation(ga_tools=population.ga_tools)
        counter = Counter()

        parent_pool = islice(population.select('mutation'),
                             self.num_mutations)
        for i, parent in enumerate(parent_pool, 1):
            logger.info('Mutation number {}. Finish when {}.'.format(
                                          i, self.num_mutations))
            counter.update([parent])
            func_data = np.random.choice(self.funcs, p=self.weights)
            func = getattr(self, func_data.name)
            logger.info(f'Using {func.__name__}.')

            try:
                mutant = func(parent, **func_data.params)

                # If the mutant was retrieved from the cache, log the
                # name.
                if mutant.name:
                    logger.debug(('Mutant "{}" retrieved from '
                                  'cache.').format(mutant.name))

                mutant_pop.members.append(mutant)

            except Exception as ex:
                errormsg = ('Mutation function "{}()" '
                            'failed on molecule "{}".').format(
                             func_data.name, parent.name)
                logger.error(errormsg, exc_info=True)

        mutant_pop -= population

        if counter_path:
            # Update counter with unselected members.
            for member in population:
                if member not in counter.keys():
                    counter.update({member: 0})
            plot_counter(counter, counter_path)

        return mutant_pop

    def random_bb(self, macro_mol, mols, key):
        """
        Substitute a building block at random.

        Parameters
        ----------
        macro_mol : :class:`.MacroMolecule`
            The cage which is to have its building block substituted.

        mols : :class:`list` of :class:`.StructUnit`
            A group of molecules from which one is used for
            substitution.

        key : :class:`function`
            A function which takes a building block of `macro_mol` and
            returns ``True`` or ``False``. For all building blocks
            which return ``True``, one is chosen at random to undergo
            mutation.

        Returns
        -------
        :class:`.MacroMolecule`
            The mutated `macro_mol`.

        """

        # Choose the building block which undergoes mutation.
        valid_bbs = [bb for bb in macro_mol.building_blocks if key(bb)]
        chosen_bb = np.random.choice(valid_bbs)

        # Make sure that the building block itself will not be picked.
        mols = [mol for mol in mols if mol is not chosen_bb]

        # Choose a replacement building block.
        replacement = np.random.choice(mols)

        # Build the new MacroMolecule.
        new_bbs = [bb for bb in macro_mol.building_blocks if
                   bb is not chosen_bb]
        new_bbs.append(replacement)
        return macro_mol.__class__(new_bbs, macro_mol.topology)

    def similar_bb(self, macro_mol, mols, key):
        """
        Substitute a building block with a similar one.

        This function first selects a building block of `macro_mol` for
        mutation. One is chosen at random from the building blocks
        where ``key(building_block) == True``.

        All  molecules in `mols` are then checked for similarity to the
        building block. The first time this mutation function is run on
        a `macro_mol`, the most similar molecule in `mols` to the
        chosen building block is used to substitute it. The next time
        this mutation function is run on the same `macro_mol` and the
        same building block is chosen, the second most similar molecule
        from `mols` is used for substitution and so on.

        Parameters
        ----------
        macro_mol : :class:`.MacroMolecule`
            The cage which is to have its building block substituted.

        mols : :class:`list` of :class:`.StructUnit`
            A group of molecules from which one is used for
            substitution.

        key : :class:`function`
            A function which takes a building block of `macro_mol` and
            returns ``True`` or ``False``. For all building blocks
            which return ``True``, one is chosen at random to undergo
            mutation.

        Returns
        -------
        :class:`.MacroMolecule`
            The mutated `macro_mol`.

        """

        if not hasattr(self, '_similar_bb'):
            # This will map every macro_mol to a set of iterators which
            # yield the most similar building blocks. 1 iterator for
            # each previously chosen building block.
            self._similar_bb = {}
        if macro_mol not in self._similar_bb:
            # Maps the macro_mol to a dict. The dict maps each
            # building block of the macro mol to an iterator.
            # The iterators yield the next most similar molecules in
            # `mols` to the building block.
            self._similar_bb[macro_mol] = {}

        # Choose the building block which undergoes mutation.
        valid_bbs = [bb for bb in macro_mol.building_blocks if key(bb)]
        chosen_bb = np.random.choice(valid_bbs)

        # Create a mapping from rdkit molecules to the StructUnits.
        mol_map = {struct_unit.inchi: struct_unit for struct_unit in mols}

        # If the building block has not been chosen before, create an
        # iterator yielding similar molecules from `mols` for it.
        if chosen_bb not in self._similar_bb[macro_mol]:
            self._similar_bb[macro_mol][chosen_bb] = iter(
                      chosen_bb.similar_molecules(m.mol for m in mols))

        sim_mol = next(self._similar_bb[macro_mol][chosen_bb])[-1]
        sim_mol_inchi = rdkit.MolToInchi(sim_mol)
        sim_struct_unit = mol_map[sim_mol_inchi]

        # If the most similar molecule in `mols` is itself, then take
        # the next most similar one.
        if sim_struct_unit is chosen_bb:
            sim_mol = next(self._similar_bb[macro_mol][chosen_bb])[-1]
            sim_mol_inchi = rdkit.MolToInchi(sim_mol)
            sim_struct_unit = mol_map[sim_mol_inchi]

        # Build the new MacroMolecule.
        new_bbs = [bb for bb in macro_mol.building_blocks if
                   bb is not chosen_bb]
        new_bbs.append(sim_struct_unit)
        return macro_mol.__class__(new_bbs, macro_mol.topology)

    def random_topology(self, macro_mol, topologies):
        """
        Changes `macro_mol` topology to a random one from `topologies`.

        A new instance of the same type as `macro_mol` is created. I.e.
        if `macro_mol` was a :class:`.Polymer` instance then a
        :class:`.Polymer` instance will be returned.

        Parameters
        ----------
        macro_mol : :class:`.MacroMolecule`
            The macromolecule which is to be mutated.

        topologies : :class:`list` of :class:`.Topology`
            This lists holds the topology instances from which one is
            selected at random to form a new molecule.

        Returns
        -------
        :class:`.MacroMolecule`
            A molecule generated by initializing a new instance
            with all the same parameters as `macro_mol` except for the
            topology.

        """

        tops = [x for x in topologies if
                repr(x) != repr(macro_mol.topology)]
        topology = np.random.choice(tops)
        return macro_mol.__class__(macro_mol.building_blocks, topology)
